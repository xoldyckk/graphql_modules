import faker from "@faker-js/faker";
import argon2 from "argon2";
import { TokenService } from "./services";
/*
generatedModuleTypes/generatedSchemaTypes are types generated by
graphql code generator from the type definition files to provide
better integration of the project with typescript
*/
import { AuthModule } from "./generatedModuleTypes";
import {
  handleSignInArgsSchemaParseErrors,
  handleSignUpArgsSchemaParseErrors,
  signInArgsSchema,
  signUpArgsSchema,
} from "./schemas";

export const authResolvers: AuthModule.Resolvers = {
  Mutation: {
    signUp: async (parent, args, context, info) => {
      try {
        /*
        safeParse returns a ZodError or the parsed data depending on
        whether an error happened while parsing the provided object.
        The returned object is a discriminated union.
        */
        const parseResult = signUpArgsSchema.safeParse(args);

        /*
        If an error is occured during parsing, success field in the returned
        object is false. handleSignUpArgsSchemaParseErrors handles the error
        and returns the response object along with the appropriate errors to
        return to the client
        */
        if (!parseResult.success) {
          return handleSignUpArgsSchemaParseErrors(parseResult.error);
        }
        /*
        if no error is occured during parsing destructure and retrieve the
        fields from args parsedResult object for making use of in the resolver
        */
        const { input } = parseResult.data;

        /*
        injector is a special function provided by graphql-modules to access different
        providers/services injected into the corresponding module(authModule here) inside the resolver
        functions of that module.
        */
        const { prisma, injector } = context;

        /*
        A prisma query making use of the filter functionality to query for a list of existing users with
        the inputted email and username fields. This is because email and username are unique fields and
        adding the same fields again in the database is a unique constraint violation. This error could've
        been propagated from and handled by the database(prisma) layer, but this way right here is much more clean.
        */
        const existingUsers = await prisma.user.findMany({
          where: {
            OR: [
              {
                email: input.email,
              },
              {
                username: input.username,
              },
            ],
          },
        });

        if (existingUsers.length > 0) {
          let userErrors: AuthModule.SignUpMutationError[] = [];

          existingUsers.forEach((existingUser) => {
            if (existingUser.email === input.email) {
              userErrors.push({
                __typename: "EmailAlreadyRegisteredError",
                message: `email '${input.email}' is already registered`,
                path: ["input", "email"],
              });
            }

            if (existingUser.username === input.username) {
              userErrors.push({
                __typename: "UsernameTakenError",
                message: `username '${input.username}' is already taken`,
                path: ["input", "username"],
                usernameSuggestion: faker.internet.userName(input.username),
              });
            }
          });

          return {
            userErrors,
            authPayload: null,
          };
        }

        /*
        argon2 library is the current most reliable way of hashing passwords for server side applications.
        */
        const passwordhash = await argon2.hash(input.password);

        /*
        Create the user
        */
        const createdUser = await prisma.user.create({
          data: {
            ...input,
            password: passwordhash,
          },
        });

        /*
        injector.get(TokenService) function gets the instance of TokenService class
        injected in the current module to make use of the createAccessToken function.
        */
        const accessToken = await injector.get(TokenService).createAccessToken({
          userId: createdUser.id,
        });

        return {
          userErrors: [],
          authPayload: { accessToken, user: createdUser },
        };
      } catch (error: any) {
        /*
        Here we could handle errors which are not related to the client(currentUser).
        Errors like database down, memory error etc.
        */
        return { userErrors: [], authPayload: null };
      }
    },

    signIn: async (parent, args, context, info) => {
      try {
        const parseResult = signInArgsSchema.safeParse(args);

        if (!parseResult.success) {
          return handleSignInArgsSchemaParseErrors(parseResult.error);
        }
        const { email, password } = parseResult.data;

        const { prisma, injector } = context;

        const existingUser = await prisma.user.findUnique({
          where: {
            email: email,
          },
        });

        if (!existingUser) {
          return {
            userErrors: [
              {
                __typename: "EmailNotRegisteredError",
                message: `email '${email}' is not registered`,
                path: ["email"],
              },
            ],
            authPayload: null,
          };
        }

        const doesPasswordMatch = await argon2.verify(
          existingUser.password,
          password
        );

        if (!doesPasswordMatch) {
          return {
            userErrors: [
              {
                __typename: "IncorrectPasswordError",
                message: `password '${password}' is incorrect`,
                path: ["password"],
              },
            ],
            authPayload: null,
          };
        }

        const accessToken = await injector.get(TokenService).createAccessToken({
          userId: existingUser.id,
        });

        return {
          userErrors: [],
          authPayload: {
            accessToken,
            user: existingUser,
          },
        };
      } catch (error) {
        return {
          userErrors: [],
          authPayload: null,
        };
      }
    },
  },
};
